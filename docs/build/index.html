<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home ¬∑ TipiFEM.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>TipiFEM.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Mesh-1">Mesh</a></li><li><a class="toctext" href="#DOF-Handler-1">DOF Handler</a></li><li><a class="toctext" href="#Quadrature-1">Quadrature</a></li><li><a class="toctext" href="#Matrix-Assembler-1">Matrix Assembler</a></li><li><a class="toctext" href="#Vector-Assembler-1">Vector Assembler</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com//tree/416399d0aa6c6ba3873f0eb16667cc4d155ace1c/docs/src/index.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="TipiFEM-Framework-for-the-Finite-Element-Method-1" href="#TipiFEM-Framework-for-the-Finite-Element-Method-1">TipiFEM - Framework for the Finite Element Method</a></h1><p>This is the documentation to TipiFEM, a framework for the implementation of Finite Element Methods in julia. The purpose of this documentation is to give the required mathematical background on which TipiFEM builds on, explain the software design of TipiFEM and how it may be used.</p><p>Since there are many different choices to make when implementing a specific FEM the package is separated into different modules.</p><p>The framework is seperated into different modules</p><ul><li><p>Support for different element types</p><ul><li><p>3-noded triangular elements</p></li><li><p>4-noded quadrilateral elements</p></li></ul></li></ul><h2><a class="nav-anchor" id="Mesh-1" href="#Mesh-1">Mesh</a></h2><p>We define a mesh <span>$\cal M$</span> as subdivision of a bounded set <span>$\Omega \subset \mathbb{R}^d$</span> into open cells of dimension <span>$&lt; d$</span>, where a cell is in general a topological space homeomorph to an open ball. The mesh is then used to represent the domain on which the problem we are trying to solve with our FEM solver is posed on.</p><p>The mesh dimension or simply dimension of a mesh is the largest dimension of one of its cells. The dimension of the ambient space <span>$d$</span> of the mesh is called the world dimension. We will generally use the notation <span>$K$</span> or <span>$K_i$</span> to talk about cells of codimension zero.</p><p><em>High level view</em></p><p>A mesh in TipiFEM is stored as an object of type <code>Mesh</code> consisting of multiple <code>MeshFunction</code>s, which store the vertex coordinates, cell topology and additional cell attributes.</p><p><em>Restrictions</em></p><p>In TipiFEM we further restrict <span>$\Omega$</span> to be a manifold surface and the cells to be polytopes or entities with the same combinatorial structure as polytopes (e.g. curvilinear elements). The first restriction is due to the algorithm that is used to wire up the incidence relation between different cells and might be lifted by a different implementation there. The mesh data structure itself may easily store non-manifold meshes. The restriction on the type of cells is only made since I wasn&#39;t aware of any problem that may be solved using finite elements where the cells have a different combinatorial structure then polytopes.</p><p><em>Features</em></p><ul><li><p>Support for different element types</p><ul><li><p>3-noded triangular elements</p></li><li><p>4-noded quadrilateral elements</p></li></ul></li><li><p>Generic mesh datastructure</p></li></ul><p>Now that we have defined what a mesh is we proceed with its implementation. A minimal representation of a polytopal-like mesh consists of a set of vertices <span>${\cal V}$</span>, where each vertex has a unique identifier and coordinate <span>$x \in \Omega$</span>, and a set of cells <span>${\cal K}$</span>, where each cell has again a unique identifier and set of vertices.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TipiFEM.Meshes.Mesh" href="#TipiFEM.Meshes.Mesh"><code>TipiFEM.Meshes.Mesh</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><p>Construct a generic mesh containing <code>K</code> cells.</p><pre><code class="language-julia">Mesh(Polygon&quot;3-node triangle&quot;)
Mesh(Union{Polygon&quot;3-node triangle&quot;, Polygon&quot;4-node quadrangle&quot;})</code></pre></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TipiFEM.Meshes.world_dim" href="#TipiFEM.Meshes.world_dim"><code>TipiFEM.Meshes.world_dim</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><p>dimension of the ambient space</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TipiFEM.Meshes.cell_type" href="#TipiFEM.Meshes.cell_type"><code>TipiFEM.Meshes.cell_type</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><p>type of cells with</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TipiFEM.Meshes.mesh_dim" href="#TipiFEM.Meshes.mesh_dim"><code>TipiFEM.Meshes.mesh_dim</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><p>dimension of codimension zero cells</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TipiFEM.Meshes.real_type" href="#TipiFEM.Meshes.real_type"><code>TipiFEM.Meshes.real_type</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><p>type used for calculations with real numbers</p></div></section><h3><a class="nav-anchor" id="MeshInterface-1" href="#MeshInterface-1">MeshInterface</a></h3><p>immutable Edge &lt;: Cell end dim(::Type{Edge}) = 1 face_count(::Type{Edge}, ::Type{Vertex}) = 2 facet(::Type{Edge}) = Vertex volume(geo::Geometry{Edge}) = point(geo, 2)[1] - point(geo, 1)[1]</p><p>Many aspects of a mesh implementation are The topology and geometry of the mesh TipiFEM contains a generic mesh implementation that may be used for various</p><p>__Simple1DMesh__</p><p>__PolytopalMesh__</p><h3><a class="nav-anchor" id="MeshFunction-1" href="#MeshFunction-1">MeshFunction</a></h3><p>The basic building block to store both geometrical and combinatorial information of a mesh is what we call a mesh function, which is just a discrete function that maps cell-indices of cells with a fixed dimension to arbitrary objects.</p><pre><code class="language-none">TipiFEM.Meshes.AbstractMeshFunction{II, VI}</code></pre><p>Lets start with some examples of how mesh functions may be used to store the topology of a mesh. We begin with a simple unstructed two dimensional mesh as of Fig #X by constructing a mesh function that maps indices of triangles to vertex indices.</p><pre><code class="language-julia">julia&gt; using TipiFEM, TipiFEM.Meshes, TipiFEM.PolytopalMesh

julia&gt; mf = MeshFunction(Polytope&quot;3-node triangle&quot;, NTuple{3, Index&quot;1-node point&quot;})
0 element HomogenousMeshFunction Polytope&quot;3-node triangle&quot; ‚Üí Tuple{TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;},TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;},TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}}

julia&gt; push!(mf, (1, 4, 2))
TipiFEM.Meshes.Index{Polytope&quot;3-node triangle&quot;}(1)

julia&gt; push!(mf, (1, 3, 4))
TipiFEM.Meshes.Index{Polytope&quot;3-node triangle&quot;}(2)

julia&gt; push!(mf, (1, 3, 4))
TipiFEM.Meshes.Index{Polytope&quot;3-node triangle&quot;}(3)</code></pre><p>The value table <span>$mf$</span> is then:</p><table><tr><th>i</th><th>f(i)</th></tr><tr><td>Index&quot;3-node triangle&quot;(1)</td><td>(Index&quot;1-node point&quot;(1), Index&quot;1-node point&quot;(4), Index&quot;1-node point&quot;(2))</td></tr><tr><td>Index&quot;3-node triangle&quot;(2)</td><td>(Index&quot;1-node point&quot;(1), Index&quot;1-node point&quot;(3), Index&quot;1-node point&quot;(4))</td></tr></table><p>Note how automatically two indices for the triangles are created and how the tuple of integers is converted into a tuple of indices. We can now look at the internal storage representation of the mesh function.</p><pre><code class="language-julia">julia&gt; domain(mf)
Base.OneTo(TipiFEM.Meshes.Index{Polytope&quot;3-node triangle&quot;}(3))

julia&gt; image(mf)
3-element Array{Tuple{TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;},TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;},TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}},1}:
 (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(2))
 (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4))
 (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4))</code></pre><p>We see that the indices in this case are stored as a leightweight <code>UnitRange</code> object of triangle indices, where a UnitRange object stores only the starting and end value of a range eliminated the need to store all indices or to store indices implicitly by their index. The image of the mesh function however is stored as a regular Array of tuples.</p><p>Now that we have a mesh function that contains some values we can further explore some aspects of the <code>MeshFunction</code> interface. The mesh function may be evaluated at any index by calling the <code>[]</code> operator.</p><pre><code class="language-julia">julia&gt; mf[Index&quot;3-node triangle&quot;(1)]
(TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(2))</code></pre><p>In case we know the integer index of the value inside the values array we can also evaluate the function using that index instead of the triangle index, which is not an integer by itself, eliminating the computation of the integer index from the triangle index.</p><pre><code class="language-julia">julia&gt; mf[1]
(TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(2))</code></pre><p>Note that in this case the integer index and the triangle index are equal, which will not be the case if the domain is not a UnitRange beginning at one (see example #X).</p><p>Iteration over all values works just like with a regular Array:</p><pre><code class="language-julia">(TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(2))
(TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4))
(TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4))
julia&gt; for connectivity in mf
         println(connectivity)
       end</code></pre><p>However in some cases the indices are also required for which the <code>graph</code> function is useful:</p><pre><code class="language-julia">index: TipiFEM.Meshes.Index{Polytope&quot;3-node triangle&quot;}(1), connectivity: (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(2))
index: TipiFEM.Meshes.Index{Polytope&quot;3-node triangle&quot;}(2), connectivity: (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4))
index: TipiFEM.Meshes.Index{Polytope&quot;3-node triangle&quot;}(3), connectivity: (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4))
julia&gt; for (index, connectivity) in graph(mf)
         println(&quot;index: &quot;, index, &quot;, connectivity: &quot;, connectivity)
       end</code></pre><p>Just like iteration over a mesh function works as if it was a regular array, many other functions that work on regular arrays also work with mesh functions (e.g. <code>map</code>, <code>reduce</code> etc.). We might for example want obtain all edges of the triangles stored in <code>mf</code>. Assuming a fixed node numbering convention, where the vertices of each triangle are stored in counter clockwise order, we can get all edges like this:</p><pre><code class="language-julia">julia&gt; # construct a mesh function that maps triangles to the connectivity of all of its edges
       triangle_edges = map(mf) do connectivity
         ((connectivity[1], connectivity[2]),
          (connectivity[2], connectivity[3]),
          (connectivity[3], connectivity[1]))
       end
3 element HomogenousMeshFunction Polytope&quot;3-node triangle&quot; ‚Üí Tuple{Tuple{TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;},TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}},Tuple{TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;},TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}},Tuple{TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;},TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}}}
 (1, ((TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4)), (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(2)), (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(2), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1))))
 (2, ((TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3)), (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4)), (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1))))
 (3, ((TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3)), (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(3), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4)), (TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(4), TipiFEM.Meshes.Index{Polytope&quot;1-node point&quot;}(1))))

julia&gt; # remove duplicate edges
       edges = MeshFunction(Edge, NTuple{2, Index&quot;1-node point&quot;})
ERROR: UndefVarError: Edge not defined

julia&gt; for edges in triangle_edges
         for edge in triangle_edges
           if edge[2]&lt;edge[1]
             push!(edges, edge)
           end
         end
       end</code></pre><p>Now we proceed with a more complex example</p><p>map indices of triangles and quadrangles to vertex indices. For this purpose we can either construct two mesh functions, one for the triangles and one for the quadrangles, and union them or create a single mesh function that stores both triangles and quadrangles.</p><pre><code class="language-none">mf1 = MeshFunction(Polytope&quot;3-node triangle&quot;, Array{Vertex, 1})()
mf2 = MeshFunction(Polytope&quot;3-node quadrangle&quot;, Array{Vertex, 1})()
push!(mf1, [1, 4, 2])
push!(mf2, [1, 3, 4])
mf = mf1 ‚à™ mf2</code></pre><p>The construction of a mesh cell is straightforward by calling</p><p>The mesh is represented as a set of mesh functions, which we define as a discrete function that maps cell-indices of cells with a fixed dimension to arbitrary objects.</p><p>The central data-type used by the mesh is a <code>MeshFunction</code>. It is defined as a discrete function that maps cell-indices of cells with a fixed dimension to arbitrary objects. <code>MeshFunctions</code> are used to store the connectivity, material parameters or user defined attributes of mesh cells. Together a set of mesh functions may then define all properties of the cells in the mesh and give them an identity through their index. Currently there exist two different concrete types of MeshFunctions.</p><p>The discreteness of a MeshFunction is expressed by</p><p>Essentially a MeshFunction is just an interface around a pair of equally sized <code>AbstractArrays</code> storing cell indices and values. Since the meaning of a MeshFunction is only clear in the context it is being used the</p><p>__Scalar discrete function__</p><h4><a class="nav-anchor" id="A-simple-mesh-1" href="#A-simple-mesh-1">A simple mesh</a></h4><p>__Connectivity__</p><pre><code class="language-none">trias = MeshFunction(Polytope&quot;3-node triangle&quot;, SVector{3, Index&quot;1-node point&quot;})
push!(trias, [v1, v4, v2])
push!(trias, [v1, v3, v4])</code></pre><p>__Geometry__</p><pre><code class="language-none">nodes = MeshFunction(Polytope&quot;1-node point&quot;, SVector{2, Float64})
v1 = push!(nodes, [0, 0])
v2 = push!(nodes, [0, 1])
v3 = push!(nodes, [1, 0])
v4 = push!(nodes, [0.5, 0.5])</code></pre><p>In combination with the connectivity the vertex coordinates may be used to calculate the area of all triangles</p><pre><code class="language-none">TipiFEM.Meshes.domain
TipiFEM.Meshes.image
TipiFEM.Meshes.graph
TipiFEM.Meshes.idxtype
TipiFEM.Meshes.cell_type
TipiFEM.Meshes.eltype
TipiFEM.Meshes.length
TipiFEM.Meshes.start
TipiFEM.Meshes.done
TipiFEM.Meshes.next
TipiFEM.Meshes.getindex
TipiFEM.Meshes.map</code></pre><p>The MeshFunction type has two fields, one for the cell indices</p><p>The actual storage layout</p><p>__Example__ Let&#39;s begin with an discrete scalar function on a set of triangles. Such a function may for example assign each triangle its volume.</p><pre><code class="language-none"># construct a mesh function mapping triangles to Float64 (Real) values
mf=MeshFunction(Polytope&quot;3-node triangle&quot;, Float64)</code></pre><p>Adding values is as easy as:</p><pre><code class="language-none">push!(mf, Index&quot;3-node triangle&quot;(1), 1)
push!(mf, Index&quot;3-node triangle&quot;(1), 2)</code></pre><p>Now just like with a regular array <code>sum(mf)</code></p><pre><code class="language-none">sum(mf)</code></pre><pre><code class="language-none">MeshFunction(Union{Polytope&quot;4-node quadrangle&quot;, Polytope&quot;3-node triangle&quot;}, Float64)</code></pre><p><strong>MeshTopology</strong></p><p>The topology of the mesh is represented by incidence relations stored as a <span>$(d+1) \times (d+1)$</span> Matrix ùïÄ of <code>Connectivity</code>-valued <code>MeshFunction</code>s, where ùïÄ<span>$(d_1, d_2)$</span> stores the incident <span>$d_2$</span> dimensional cells of <span>$d_1$</span> dimensional cells.</p><h3><a class="nav-anchor" id="MeshCell-1" href="#MeshCell-1">MeshCell</a></h3><p>Since the cells of a mesh are stored implicitly through <code>MeshFunctions</code> their data-types also do not store any information. A concrete <code>MeshCell</code> (e.g. a <code>Polytope</code>) is therefore implemented as a singleton type in julia, whose only purpose is to allow distinguishing different types of cells. Intrinsic properties of mesh cells may then be defined by simple functions taking a concrete <code>MeshCell</code> as an argument. The dimension of a 3-node triangle for example is defined like this:</p><pre><code class="language-none">dim(::Polytope&quot;3-node triangle&quot;) = 2</code></pre><h4><a class="nav-anchor" id="Connectivity-1" href="#Connectivity-1">Connectivity</a></h4><h4><a class="nav-anchor" id="Geometry-1" href="#Geometry-1">Geometry</a></h4><h4><a class="nav-anchor" id="Misc-1" href="#Misc-1">Misc</a></h4><p><strong>Dim, Codim</strong></p><p>The <code>Dim</code> and <code>Codim</code> types are used to represent dimension and codimension information. Since in most situations the dimension and the codimension is already known at compile time these types are implemented as singleton types that store the value of the (co)dimension as a parametric type (note that the value is an integer and not a type). This allows us to dispatch on the (co)dimension, which is especially handy in cases, where the knowledge of the (co)dimension at compile time allows generation of efficient code.</p><pre><code class="language-none">Connectivity&quot;3-node triangle ‚Üí 1-node point&quot;</code></pre><p>Mandatory information about</p><h2><a class="nav-anchor" id="DOF-Handler-1" href="#DOF-Handler-1">DOF Handler</a></h2><p>The dof-handler maps dofs to unique integer indices. A simple dof handler that works for a nodal basis may be implemented in two steps. The first step, an initialization procedure, has the be run only once. Here we assign each cell type a disjoint integer range as large as the number of cells of this type in the mesh. Now every</p><p>implemented by first assigning disjoint integer ranges to each cell type and using the starting point of each interval as an offset</p><p>the number of cells per type and</p><div>\[\sum_K cells_per_type(K)\]</div><h2><a class="nav-anchor" id="Quadrature-1" href="#Quadrature-1">Quadrature</a></h2><p>The <code>Quadrature</code> module provides generic code for the approximation of integrals on a mesh by means of a weighted sum of point values.</p><div>\[\int_K f(\mathbb{x}) \mathrm{d}K \approx \sum_{j=1}^n w_j^n f(c_j^n)\]</div><p>Evaluation of the approximation is by means of calling <code>integrate(f, Kis)</code> with <code>f</code> the integrand <span>$f$</span> in procedural form and <code>Kis</code> a set of cells given as a <code>MeshFunction</code> of cell <code>Geometry</code> objects.</p><p>The concrete mesh implementation is then only obligated to define quadrature weights and nodes before the <code>integrate</code></p><p>The domain in form of a <code>Mesh</code> object and integrand in procedural form may then be given to <code>integrant</code></p><p>The concrete mesh implmentation defines quadrature weights and nodes get defined by</p><p>For the approximation of integrals on functions given in procedural form</p><h2><a class="nav-anchor" id="Matrix-Assembler-1" href="#Matrix-Assembler-1">Matrix Assembler</a></h2><h2><a class="nav-anchor" id="Vector-Assembler-1" href="#Vector-Assembler-1">Vector Assembler</a></h2><p><img src="../assets/tipi.svg" alt="Image of Yaktocat"/></p><footer><hr/></footer></article></body></html>
